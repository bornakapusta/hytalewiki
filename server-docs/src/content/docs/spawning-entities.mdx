---
title: Spawning Entities
description: Create entities, add components, and spawn them in the world
---

**Goal:** Spawn custom entities with components at a location.

**Prerequisites:** [Handling Events](/handling-events)

## Step 1: Understand the ECS Pattern

Entities are composed of components in a data-oriented architecture:

```
Entity (just a Ref identifier)
├── TransformComponent (position, rotation)
├── ModelComponent (3D model)
├── UUIDComponent (unique ID)
├── Velocity (movement)
└── ... other components
```

### The Holder/Ref/Store Pattern

| Type | Purpose | Lifecycle |
|------|---------|-----------|
| **Holder** | Staging container for components | Temporary - used during creation |
| **Ref** | Stable reference to entity | Persistent - survives reorganization |
| **Store** | Main entity storage | World-level singleton |

```java
// 1. Create holder (staging area)
Holder<EntityStore> holder = registry.newHolder();
holder.addComponent(TransformComponentType, transform);
holder.addComponent(ModelComponentType, model);

// 2. Add to store, get ref
Ref<EntityStore> ref = store.addEntity(holder, AddReason.SPAWN);

// 3. Use ref for future access
TransformComponent t = store.getComponent(ref, TransformComponentType);
```

## Step 2: Get a Reference to the World

```kotlin
import com.hypixel.hytale.server.core.universe.Universe
import com.hypixel.hytale.server.core.universe.world.World

// Get world by name
val world: World? = Universe.get().worlds["default"]

// Or from an event
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    val world = event.world
}
```

## Step 3: Create and Spawn an Entity

```kotlin
import com.hypixel.hytale.server.core.entity.Entity
import org.joml.Vector3d

fun spawnEntity(world: World, position: Vector3d) {
    world.execute {
        val entity = MyEntity()
        world.entityStore.spawnEntity(entity, position)
    }
}
```

Always spawn on the world thread using `world.execute {}`.

## Step 4: Spawn an Item Drop

```kotlin
import com.hypixel.hytale.server.core.inventory.ItemStack
import com.hypixel.hytale.server.core.modules.entity.component.ItemComponent
import org.joml.Vector3d

fun dropItem(world: World, position: Vector3d, itemStack: ItemStack) {
    world.execute {
        val holder = ItemComponent.generateItemDrop(
            world.entityStore.store,
            itemStack,
            position,
            null  // velocity
        )
        world.entityStore.store.addEntity(holder, AddReason.SPAWN)
    }
}

// Usage
dropItem(world, Vector3d(0.0, 100.0, 0.0), ItemStack("Tool_Pickaxe_Iron", 1))
```

## Step 5: Access Entity Components

Using Holder:

```kotlin
val holder = entity.toHolder()

// Get component
val transform = holder.getComponent(TransformComponent.getComponentType())
val uuid = holder.getComponent(UUIDComponent.getComponentType())?.uuid

// Modify position
transform?.position?.assign(x, y, z)
```

Using Store and Ref:

```kotlin
val ref = entity.reference ?: return
val store = world.entityStore.store

// Get component
val transform = store.getComponent(ref, TransformComponent.getComponentType())
val position = transform?.position

// Check if valid
if (ref.isValid()) {
    // Entity still exists
}
```

## Step 6: Iterate World Entities

```kotlin
world.entityStore.forEach { ref, accessor ->
    val entity = accessor.getComponent(ref, Entity.getComponentType())
    val transform = accessor.getComponent(ref, TransformComponent.getComponentType())

    // Process entity
    logger.atInfo().log("Entity at ${transform?.position}")
}
```

## Step 7: Remove an Entity

```kotlin
fun removeEntity(entity: Entity) {
    entity.remove()
}

// Or via store
fun removeEntityByRef(world: World, ref: Ref<EntityStore>) {
    world.execute {
        world.entityStore.store.removeEntity(ref, RemoveReason.DESPAWN)
    }
}
```

## Step 8: Spawn with Custom Components

```kotlin
fun spawnCustomEntity(world: World, position: Vector3d) {
    world.execute {
        // Create holder for staging components
        val registry = world.entityStore.registry
        val holder = registry.newHolder()

        // Add transform
        val transform = TransformComponent()
        transform.position.assign(position.x, position.y, position.z)
        holder.addComponent(TransformComponent.getComponentType(), transform)

        // Add UUID
        holder.addComponent(UUIDComponent.getComponentType(), UUIDComponent())

        // Add to world
        val ref = world.entityStore.store.addEntity(holder, AddReason.SPAWN)
    }
}
```

## Complete Example

Spawn mobs at player location:

```kotlin
package com.example.myplugin

import com.hypixel.hytale.server.core.command.system.CommandContext
import com.hypixel.hytale.server.core.command.system.arguments.types.ArgTypes
import com.hypixel.hytale.server.core.command.system.basecommands.AbstractPlayerCommand
import com.hypixel.hytale.server.core.entity.Entity
import com.hypixel.hytale.server.core.modules.entity.component.TransformComponent
import com.hypixel.hytale.server.core.universe.PlayerRef
import com.hypixel.hytale.server.core.universe.world.World
import com.hypixel.hytale.server.core.universe.world.storage.EntityStore
import hytale.ecs.Ref
import hytale.ecs.Store
import org.joml.Vector3d

class SpawnMobCommand : AbstractPlayerCommand("spawnmob", "Spawn a mob") {
    private val modelArg = withRequiredArg("model", "Entity model", ArgTypes.MODEL_ASSET)
    private val countArg = withDefaultArg("count", "Number to spawn", ArgTypes.INTEGER, 1, "1")

    override fun execute(
        context: CommandContext,
        store: Store<EntityStore>,
        ref: Ref<EntityStore>,
        playerRef: PlayerRef,
        world: World
    ) {
        val model = context.get(modelArg)
        val count = context.get(countArg)

        // Get player position
        val playerTransform = store.getComponent(ref, TransformComponent.getComponentType())
        val position = playerTransform?.position ?: return

        // Spawn entities
        world.execute {
            repeat(count) { i ->
                val spawnPos = Vector3d(
                    position.x + (i * 2),  // Offset each spawn
                    position.y,
                    position.z
                )
                spawnEntityAtPosition(world, model, spawnPos)
            }
        }

        context.sendMessage(Message.raw("Spawned $count entities"))
    }

    private fun spawnEntityAtPosition(world: World, model: Any, position: Vector3d) {
        // Entity spawning logic depends on entity type
        // This is a simplified example
        world.entityStore.spawnEntity(/* entity */, position)
    }
}
```

## Common Components

| Component | Purpose |
|-----------|---------|
| `TransformComponent` | Position, rotation |
| `UUIDComponent` | Unique identifier |
| `ModelComponent` | 3D model reference |
| `Velocity` | Movement vector |
| `ItemComponent` | Item drop data |
| `DespawnComponent` | Auto-despawn timing |
| `HeadRotation` | Look direction |

## Entity Lifecycle

### Lifecycle States

```
1. STAGING     → Holder being composed
2. ADDING      → addEntity() called with AddReason
3. ACTIVE      → Entity in store, systems processing
4. REMOVING    → removeEntity() called with RemoveReason
5. REMOVED     → Ref invalidated, entity gone
```

### AddReason and RemoveReason

```java
public enum AddReason {
    SPAWN,  // New entity created
    LOAD    // Entity loaded from persistence
}

public enum RemoveReason {
    REMOVE,  // Entity destroyed/despawned
    UNLOAD   // Entity unloaded for persistence
}
```

### Listening to Lifecycle Events

Use `RefSystem` to hook into entity lifecycle:

```kotlin
class EntityLifecycleTracker : RefSystem<EntityStore>() {
    override fun getQuery(): Query<EntityStore> = Query.any()

    override fun onEntityAdded(
        ref: Ref<EntityStore>,
        reason: AddReason,
        store: Store<EntityStore>,
        buffer: CommandBuffer<EntityStore>
    ) {
        when (reason) {
            AddReason.SPAWN -> logger.info("Entity spawned: $ref")
            AddReason.LOAD -> logger.info("Entity loaded: $ref")
        }
    }

    override fun onEntityRemove(
        ref: Ref<EntityStore>,
        reason: RemoveReason,
        store: Store<EntityStore>,
        buffer: CommandBuffer<EntityStore>
    ) {
        when (reason) {
            RemoveReason.REMOVE -> logger.info("Entity removed: $ref")
            RemoveReason.UNLOAD -> logger.info("Entity unloaded: $ref")
        }
    }
}
```

## Archetype Iteration Patterns

### Query-Based Iteration

```kotlin
// Define query once
val MOVABLE_QUERY = Query.and(
    TransformComponentType,
    VelocityComponentType,
    Query.not(FrozenComponentType)
)

// Iterate matching entities
fun processMovableEntities(store: Store<EntityStore>) {
    for (chunk in store.getChunks(MOVABLE_QUERY)) {
        for (i in 0 until chunk.size()) {
            val transform = chunk.getComponent(i, TransformComponentType)
            val velocity = chunk.getComponent(i, VelocityComponentType)

            // Update position
            transform.position.apply {
                x += velocity.x
                y += velocity.y
                z += velocity.z
            }
        }
    }
}
```

### Safe Iteration with CommandBuffer

Never modify entities directly during iteration:

```kotlin
fun despawnOldEntities(store: Store<EntityStore>, maxAge: Long) {
    val buffer = store.takeCommandBuffer()
    val now = System.currentTimeMillis()

    for (chunk in store.getChunks(AgeComponentType)) {
        for (i in 0 until chunk.size()) {
            val age = chunk.getComponent(i, AgeComponentType)
            if (now - age.createdAt > maxAge) {
                // Safe - queued for later
                buffer.removeEntity(chunk.getRef(i), RemoveReason.REMOVE)
            }
        }
    }

    // Execute after iteration complete
    store.executeCommandBuffer(buffer)
}
```

### Efficient Component Checks

```kotlin
// Check if entity has component
fun hasComponent(store: Store<EntityStore>, ref: Ref<EntityStore>): Boolean {
    return store.getComponent(ref, TransformComponentType) != null
}

// Get archetype for component composition check
fun hasAllComponents(store: Store<EntityStore>, ref: Ref<EntityStore>): Boolean {
    val archetype = store.getArchetype(ref)
    return archetype.contains(TransformComponentType) &&
           archetype.contains(VelocityComponentType)
}
```

## Batch Entity Operations

### Spawning Multiple Entities

```kotlin
fun spawnSwarm(world: World, center: Vector3d, count: Int) {
    world.execute {
        val registry = world.entityStore.registry
        val buffer = world.entityStore.store.takeCommandBuffer()

        repeat(count) { i ->
            val holder = registry.newHolder()

            // Add components
            val transform = TransformComponent()
            transform.position.set(
                center.x + (i % 10) * 2,
                center.y,
                center.z + (i / 10) * 2
            )
            holder.addComponent(TransformComponentType, transform)
            holder.addComponent(UUIDComponentType, UUIDComponent())
            holder.addComponent(VelocityComponentType, Velocity())

            // Queue spawn
            buffer.addEntity(holder, AddReason.SPAWN)
        }

        // Execute all spawns
        world.entityStore.store.executeCommandBuffer(buffer)
    }
}
```

### Removing Entities by Query

```kotlin
fun removeAllProjectiles(store: Store<EntityStore>) {
    val buffer = store.takeCommandBuffer()

    for (chunk in store.getChunks(ProjectileComponentType)) {
        for (i in 0 until chunk.size()) {
            buffer.removeEntity(chunk.getRef(i), RemoveReason.REMOVE)
        }
    }

    store.executeCommandBuffer(buffer)
}
```

## Thread Safety

Always modify entities on the world thread:

```kotlin
// Check thread
if (world.isInThread()) {
    // Safe to modify
}

// Execute on world thread
world.execute {
    // Safe here
    entity.remove()
}
```

### Safe Cross-Thread Access

```kotlin
// From another thread, schedule work on world thread
fun scheduleEntityRemoval(world: World, ref: Ref<EntityStore>) {
    world.execute {
        if (ref.isValid()) {  // Always check!
            world.entityStore.store.removeEntity(ref, RemoveReason.REMOVE)
        }
    }
}
```

## Performance Tips

1. **Cache queries** - Don't create query objects in hot paths
2. **Use CommandBuffer** - Never modify during iteration
3. **Batch operations** - Group spawns/removes together
4. **Check isValid()** - Refs can become invalid asynchronously
5. **Minimize archetype changes** - Adding/removing components causes entity moves

## Next Steps

- [Manipulating Blocks](/manipulating-blocks) - World block editing
- [Custom Components](/custom-components) - Create your own components
- [ECS Components](/ecs-components) - All available components
- [Advanced ECS](/advanced-ecs) - Advanced patterns and performance
- [System Types](/system-types) - System implementation reference
