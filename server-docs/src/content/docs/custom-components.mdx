---
title: Custom Components
description: Create and register your own ECS components
---

**Goal:** Build a custom component to track player stats.

**Prerequisites:** [Spawning Entities](/spawning-entities)

## Step 1: Understand the ECS Pattern

The ECS (Entity Component System) separates data from behavior:

- **Component** - Data container (position, health, stats)
- **Entity** - Collection of components (via Holder/Ref)
- **System** - Logic that processes components

```
Player Entity
├── TransformComponent (position)
├── Player (player data)
├── UUIDComponent (unique ID)
└── YourCustomComponent (your data)
```

## Step 2: Create a Component Class

Implement the `Component` interface:

```kotlin
import com.hypixel.hytale.server.core.universe.world.storage.EntityStore
import hytale.ecs.Component

class PlayerStatsComponent : Component<EntityStore> {
    var kills: Int = 0
    var deaths: Int = 0
    var blocksPlaced: Int = 0
    var blocksBroken: Int = 0

    override fun clone(): PlayerStatsComponent {
        return PlayerStatsComponent().also {
            it.kills = this.kills
            it.deaths = this.deaths
            it.blocksPlaced = this.blocksPlaced
            it.blocksBroken = this.blocksBroken
        }
    }

    override fun cloneSerializable(): Component<EntityStore> = clone()
}
```

## Step 3: Add a Codec for Serialization

If your component needs to persist:

```kotlin
import com.hypixel.hytale.shared.codec.BuilderCodec
import com.hypixel.hytale.shared.codec.Codec
import com.hypixel.hytale.shared.codec.KeyedCodec

class PlayerStatsComponent : Component<EntityStore> {
    var kills: Int = 0
    var deaths: Int = 0
    var blocksPlaced: Int = 0
    var blocksBroken: Int = 0

    companion object {
        val CODEC: BuilderCodec<PlayerStatsComponent> = BuilderCodec.builder(
            PlayerStatsComponent::class.java,
            { PlayerStatsComponent() }
        )
            .append(
                KeyedCodec("kills", Codec.INT),
                { obj, value -> obj.kills = value },
                { obj -> obj.kills }
            )
            .append(
                KeyedCodec("deaths", Codec.INT),
                { obj, value -> obj.deaths = value },
                { obj -> obj.deaths }
            )
            .append(
                KeyedCodec("blocksPlaced", Codec.INT),
                { obj, value -> obj.blocksPlaced = value },
                { obj -> obj.blocksPlaced }
            )
            .append(
                KeyedCodec("blocksBroken", Codec.INT),
                { obj, value -> obj.blocksBroken = value },
                { obj -> obj.blocksBroken }
            )
            .add()
            .build()
    }

    override fun clone(): PlayerStatsComponent { /* ... */ }
    override fun cloneSerializable(): Component<EntityStore> = clone()
}
```

## Step 4: Register the Component Type

Create a component type for access:

```kotlin
import hytale.ecs.ComponentType

object MyComponents {
    lateinit var PLAYER_STATS: ComponentType<EntityStore, PlayerStatsComponent>
        private set

    fun register(registry: ComponentRegistry) {
        PLAYER_STATS = registry.registerComponent(
            PlayerStatsComponent::class.java,
            "PlayerStatsComponent",
            PlayerStatsComponent.CODEC
        )
    }
}
```

Register in plugin setup:

```kotlin
override fun setup() {
    MyComponents.register(componentRegistry)
}
```

## Step 5: Add Component to Entities

When a player connects:

```kotlin
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    val holder = event.holder

    // Check if already has component
    if (holder.getComponent(MyComponents.PLAYER_STATS) == null) {
        holder.addComponent(MyComponents.PLAYER_STATS, PlayerStatsComponent())
    }
}
```

## Step 6: Access and Modify Components

```kotlin
fun getPlayerStats(playerRef: PlayerRef): PlayerStatsComponent? {
    return playerRef.holder?.getComponent(MyComponents.PLAYER_STATS)
}

fun incrementKills(playerRef: PlayerRef) {
    getPlayerStats(playerRef)?.let { stats ->
        stats.kills++
    }
}

fun incrementDeaths(playerRef: PlayerRef) {
    getPlayerStats(playerRef)?.let { stats ->
        stats.deaths++
    }
}
```

## Step 7: Track Events

```kotlin
eventRegistry.register(PlaceBlockEvent::class.java) { event ->
    val playerRef = event.playerRef ?: return@register
    getPlayerStats(playerRef)?.blocksPlaced++
}

eventRegistry.register(BreakBlockEvent::class.java) { event ->
    val playerRef = event.playerRef ?: return@register
    getPlayerStats(playerRef)?.blocksBroken++
}
```

## Complete Example

A full stats tracking plugin:

```kotlin
package com.example.myplugin

import com.hypixel.hytale.server.core.Message
import com.hypixel.hytale.server.core.command.system.CommandContext
import com.hypixel.hytale.server.core.command.system.basecommands.AbstractPlayerCommand
import com.hypixel.hytale.server.core.entity.entities.Player
import com.hypixel.hytale.server.core.event.events.ecs.BreakBlockEvent
import com.hypixel.hytale.server.core.event.events.ecs.PlaceBlockEvent
import com.hypixel.hytale.server.core.event.events.player.PlayerConnectEvent
import com.hypixel.hytale.server.core.plugin.JavaPlugin
import com.hypixel.hytale.server.core.plugin.JavaPluginInit
import com.hypixel.hytale.server.core.universe.PlayerRef
import com.hypixel.hytale.server.core.universe.world.World
import com.hypixel.hytale.server.core.universe.world.storage.EntityStore
import hytale.ecs.Component
import hytale.ecs.ComponentType
import hytale.ecs.Ref
import hytale.ecs.Store

// Component
class PlayerStatsComponent : Component<EntityStore> {
    var kills: Int = 0
    var deaths: Int = 0
    var blocksPlaced: Int = 0
    var blocksBroken: Int = 0

    fun getKDRatio(): Double {
        return if (deaths == 0) kills.toDouble() else kills.toDouble() / deaths
    }

    override fun clone(): PlayerStatsComponent {
        return PlayerStatsComponent().also {
            it.kills = this.kills
            it.deaths = this.deaths
            it.blocksPlaced = this.blocksPlaced
            it.blocksBroken = this.blocksBroken
        }
    }

    override fun cloneSerializable(): Component<EntityStore> = clone()
}

// Plugin
class StatsPlugin(init: JavaPluginInit) : JavaPlugin(init) {

    companion object {
        lateinit var PLAYER_STATS: ComponentType<EntityStore, PlayerStatsComponent>
            private set
    }

    override fun setup() {
        // Register component type
        // PLAYER_STATS = componentRegistry.registerComponent(...)

        // Add stats to new players
        eventRegistry.register(PlayerConnectEvent::class.java) { event ->
            val holder = event.holder
            if (holder.getComponent(PLAYER_STATS) == null) {
                holder.addComponent(PLAYER_STATS, PlayerStatsComponent())
            }
        }

        // Track block placement
        eventRegistry.register(PlaceBlockEvent::class.java) { event ->
            val playerRef = event.playerRef ?: return@register
            playerRef.holder?.getComponent(PLAYER_STATS)?.blocksPlaced++
        }

        // Track block breaking
        eventRegistry.register(BreakBlockEvent::class.java) { event ->
            val playerRef = event.playerRef ?: return@register
            playerRef.holder?.getComponent(PLAYER_STATS)?.blocksBroken++
        }

        // Register stats command
        commandRegistry.registerCommand(StatsCommand())
    }

    override fun start() {
        logger.atInfo().log("StatsPlugin started")
    }

    override fun shutdown() {
        logger.atInfo().log("StatsPlugin shutdown")
    }
}

// Command to view stats
class StatsCommand : AbstractPlayerCommand("stats", "View your stats") {
    override fun execute(
        context: CommandContext,
        store: Store<EntityStore>,
        ref: Ref<EntityStore>,
        playerRef: PlayerRef,
        world: World
    ) {
        val stats = playerRef.holder?.getComponent(StatsPlugin.PLAYER_STATS)
        if (stats == null) {
            context.sendMessage(Message.raw("No stats found"))
            return
        }

        context.sendMessage(Message.raw("=== Your Stats ==="))
        context.sendMessage(Message.raw("Kills: ${stats.kills}"))
        context.sendMessage(Message.raw("Deaths: ${stats.deaths}"))
        context.sendMessage(Message.raw("K/D Ratio: ${"%.2f".format(stats.getKDRatio())}"))
        context.sendMessage(Message.raw("Blocks Placed: ${stats.blocksPlaced}"))
        context.sendMessage(Message.raw("Blocks Broken: ${stats.blocksBroken}"))
    }
}
```

## Using Store and Ref

For direct store access:

```kotlin
fun modifyViaStore(world: World, ref: Ref<EntityStore>) {
    val store = world.entityStore.store

    // Get component
    val stats = store.getComponent(ref, StatsPlugin.PLAYER_STATS)

    // Modify
    stats?.kills++

    // Put back (if needed for specific component types)
    // store.putComponent(ref, StatsPlugin.PLAYER_STATS, stats)
}
```

## Common Marker Components

Simple components without data act as tags:

```kotlin
class Invulnerable : Component<EntityStore> {
    override fun clone() = Invulnerable()
    override fun cloneSerializable() = clone()
}

// Check if entity is invulnerable
if (holder.getComponent(INVULNERABLE) != null) {
    // Skip damage
}
```

## Example: Poison Component

A complete example showing a component with a system that processes it:

### PoisonComponent

```kotlin
class PoisonComponent : Component<EntityStore> {
    var damagePerTick: Float = 1f
    var ticksRemaining: Int = 100  // 5 seconds at 20 TPS
    var source: UUID? = null       // Who applied the poison

    override fun clone() = PoisonComponent().also {
        it.damagePerTick = damagePerTick
        it.ticksRemaining = ticksRemaining
        it.source = source
    }

    override fun cloneSerializable() = clone()

    companion object {
        val CODEC: BuilderCodec<PoisonComponent> = BuilderCodec.builder(
            PoisonComponent::class.java,
            { PoisonComponent() }
        )
            .append(KeyedCodec("damagePerTick", Codec.FLOAT),
                { o, v -> o.damagePerTick = v }, { o -> o.damagePerTick })
            .append(KeyedCodec("ticksRemaining", Codec.INT),
                { o, v -> o.ticksRemaining = v }, { o -> o.ticksRemaining })
            .add()
            .build()
    }
}
```

### PoisonSystem

```kotlin
class PoisonSystem : EntityTickingSystem<EntityStore>() {
    companion object {
        lateinit var POISON: ComponentType<EntityStore, PoisonComponent>
    }

    override fun getQuery(): Query<EntityStore> {
        // Only process entities with both Poison and Health
        return Query.and(POISON, HealthComponentType)
    }

    override fun tick(
        deltaTime: Float,
        tick: Int,
        index: Int,
        chunk: ArchetypeChunk<EntityStore>,
        store: Store<EntityStore>,
        buffer: CommandBuffer<EntityStore>
    ) {
        val poison = chunk.getComponent(index, POISON)
        val health = chunk.getComponent(index, HealthComponentType)
        val ref = chunk.getRef(index)

        // Apply damage
        health.current -= poison.damagePerTick

        // Decrement duration
        poison.ticksRemaining--

        // Remove poison when expired
        if (poison.ticksRemaining <= 0) {
            buffer.removeComponent(ref, POISON)
        }

        // Check for death
        if (health.current <= 0) {
            buffer.addComponent(ref, DeathComponentType, DeathComponent().apply {
                cause = DeathCause.POISON
                killer = poison.source
            })
        }
    }
}
```

### Applying Poison

```kotlin
// Apply poison when hit by poison arrow
eventRegistry.register(EntityHitEvent::class.java) { event ->
    val projectile = event.projectile ?: return@register
    if (!isPoisonArrow(projectile)) return@register

    val targetRef = event.targetRef
    val holder = targetRef.holder ?: return@register

    // Add or refresh poison component
    val existing = holder.getComponent(PoisonSystem.POISON)
    if (existing != null) {
        // Refresh duration, don't stack damage
        existing.ticksRemaining = 100
    } else {
        holder.addComponent(PoisonSystem.POISON, PoisonComponent().apply {
            damagePerTick = 1f
            ticksRemaining = 100
            source = getShooterUuid(projectile)
        })
    }
}
```

### Register in Plugin

```kotlin
override fun setup() {
    // Register component
    PoisonSystem.POISON = componentRegistry.registerComponent(
        PoisonComponent::class.java,
        "PoisonComponent",
        PoisonComponent.CODEC
    )

    // Register system
    componentRegistry.registerSystem(PoisonSystem())
}
```

## Next Steps

- [Component List](/ecs-components) - All built-in components
- [Spawning Entities](/spawning-entities) - Add components to entities
- [API Reference](/api-reference) - Component types and methods
