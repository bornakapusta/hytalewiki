---
title: Handling Events
description: Listen and respond to game events
---

**Goal:** Build a plugin that tracks player joins, handles chat, and protects spawn.

**Prerequisites:** [Your First Plugin](/your-first-plugin)

## Step 1: Register a Basic Event

In your plugin's `setup()`, register an event listener:

```kotlin
import com.hypixel.hytale.server.core.event.events.player.PlayerConnectEvent

override fun setup() {
    eventRegistry.register(PlayerConnectEvent::class.java) { event ->
        logger.atInfo().log("Player connected: ${event.playerRef}")
    }
}
```

## Step 2: Handle Player Chat

Listen to chat messages and respond:

```kotlin
import com.hypixel.hytale.server.core.Message
import com.hypixel.hytale.server.core.entity.entities.Player
import com.hypixel.hytale.server.core.event.events.player.PlayerChatEvent

eventRegistry.register(PlayerChatEvent::class.java) { event ->
    val message = event.message

    // Respond to specific messages
    if (message.equals("ping", ignoreCase = true)) {
        val player = event.holder.getComponent(Player.getComponentType())
        player?.sendMessage(Message.raw("Pong!"))
    }
}
```

## Step 3: Cancel Events

Some events can be cancelled to prevent the default behavior:

```kotlin
import com.hypixel.hytale.server.core.event.events.ecs.PlaceBlockEvent

eventRegistry.register(PlaceBlockEvent::class.java) { event ->
    val position = event.position

    // Protect spawn area (within 50 blocks of origin)
    if (position.x.toInt() in -50..50 &&
        position.z.toInt() in -50..50) {
        event.cancel()
        // Optionally notify player
    }
}
```

## Step 4: Use Event Priority

Control when your listener runs relative to others:

```kotlin
import com.hypixel.hytale.event.EventPriority

// Run before other listeners
eventRegistry.register(EventPriority.HIGH, PlayerConnectEvent::class.java) { event ->
    // Process early
}

// Run after other listeners (read-only)
eventRegistry.register(EventPriority.MONITOR, PlayerConnectEvent::class.java) { event ->
    // Log or monitor, don't modify
}
```

**Priority order (first to last):**
1. `LOWEST` - Runs first
2. `LOW`
3. `NORMAL` - Default
4. `HIGH`
5. `HIGHEST`
6. `MONITOR` - Runs last, read-only

## Step 5: Handle Async Events

Some events support async processing:

```kotlin
eventRegistry.registerAsync(SomeAsyncEvent::class.java) { future ->
    future.thenApply { event ->
        // Async processing
        event
    }
}
```

## Complete Example

Track player statistics:

```kotlin
package com.example.myplugin

import com.hypixel.hytale.server.core.Message
import com.hypixel.hytale.server.core.entity.entities.Player
import com.hypixel.hytale.server.core.event.events.ecs.BreakBlockEvent
import com.hypixel.hytale.server.core.event.events.ecs.PlaceBlockEvent
import com.hypixel.hytale.server.core.event.events.player.PlayerConnectEvent
import com.hypixel.hytale.server.core.event.events.player.PlayerDisconnectEvent
import com.hypixel.hytale.server.core.plugin.JavaPlugin
import com.hypixel.hytale.server.core.plugin.JavaPluginInit
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap

class StatsPlugin(init: JavaPluginInit) : JavaPlugin(init) {

    data class PlayerStats(
        var blocksPlaced: Int = 0,
        var blocksBroken: Int = 0
    )

    private val stats = ConcurrentHashMap<UUID, PlayerStats>()

    override fun setup() {
        // Track player join
        eventRegistry.register(PlayerConnectEvent::class.java) { event ->
            val uuid = event.playerRef?.uuid ?: return@register
            stats.putIfAbsent(uuid, PlayerStats())
            logger.atInfo().log("Player $uuid joined, tracking stats")
        }

        // Track player leave
        eventRegistry.register(PlayerDisconnectEvent::class.java) { event ->
            val uuid = event.playerRef?.uuid ?: return@register
            val playerStats = stats[uuid]
            logger.atInfo().log("Player $uuid left - Placed: ${playerStats?.blocksPlaced}, Broken: ${playerStats?.blocksBroken}")
        }

        // Track blocks placed
        eventRegistry.register(PlaceBlockEvent::class.java) { event ->
            val uuid = event.playerRef?.uuid ?: return@register
            stats[uuid]?.let { it.blocksPlaced++ }
        }

        // Track blocks broken
        eventRegistry.register(BreakBlockEvent::class.java) { event ->
            val uuid = event.playerRef?.uuid ?: return@register
            stats[uuid]?.let { it.blocksBroken++ }
        }
    }

    override fun start() {
        logger.atInfo().log("StatsPlugin started")
    }

    override fun shutdown() {
        // Save stats to database here
        logger.atInfo().log("StatsPlugin shutdown, saving ${stats.size} player stats")
    }
}
```

## Common Patterns

### Safe Player Access

```kotlin
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    val playerRef = event.playerRef ?: return@register
    val holder = event.holder

    val player = holder.getComponent(Player.getComponentType())
    if (player == null) {
        logger.atWarning().log("Player component not found")
        return@register
    }

    // Now safe to use player
}
```

### Global Listeners

Listen regardless of event key:

```kotlin
eventRegistry.registerGlobal(SomeKeyedEvent::class.java) { event ->
    // Called for all keys
}
```

### Unhandled Events

Handle events no other listener processed:

```kotlin
eventRegistry.registerUnhandled(SomeEvent::class.java) { event ->
    // Fallback handler
}
```

## Advanced Patterns

### Multi-Listener Coordination

When multiple plugins need to process the same event:

```kotlin
// Plugin A - Runs first, sets up data
eventRegistry.register(EventPriority.LOW, PlayerConnectEvent::class.java) { event ->
    val holder = event.holder
    // Add a custom component other listeners can use
    holder.addComponent(CustomDataType, CustomData())
}

// Plugin B - Runs later, uses the data
eventRegistry.register(EventPriority.HIGH, PlayerConnectEvent::class.java) { event ->
    val holder = event.holder
    val customData = holder.getComponent(CustomDataType)
    // Use data set by Plugin A
}
```

### Event Cancellation Edge Cases

```kotlin
// Check if already cancelled
eventRegistry.register(EventPriority.HIGH, PlaceBlockEvent::class.java) { event ->
    if (event.isCancelled) {
        // Another listener already cancelled - respect that decision
        return@register
    }

    // Your cancellation logic
    if (shouldCancel(event)) {
        event.cancel()
    }
}

// MONITOR priority should never cancel
eventRegistry.register(EventPriority.MONITOR, PlaceBlockEvent::class.java) { event ->
    // Only log - never modify or cancel at MONITOR priority
    if (event.isCancelled) {
        logger.info("Block placement was cancelled at ${event.position}")
    } else {
        logger.info("Block placed at ${event.position}")
    }
}
```

### Async Event Processing

For events that support async processing (I/O operations, database calls):

```kotlin
eventRegistry.registerAsync(SomeAsyncEvent::class.java) { future ->
    future.thenCompose { event ->
        // Perform async operation
        database.fetchPlayerDataAsync(event.playerId)
    }.thenApply { data ->
        // Process result
        processData(data)
    }.exceptionally { error ->
        logger.error("Async processing failed", error)
        null
    }
}
```

### ECS Events vs Global Events

Hytale has two event systems:

**Global Events** (EventBus) - Server-wide events:
```kotlin
// Register via plugin eventRegistry
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    // Runs on event bus thread
}
```

**ECS Events** (EntityEventSystem/WorldEventSystem) - Entity-scoped events:
```kotlin
// Register as a system in ComponentRegistry
class DamageEventHandler : EntityEventSystem<EntityStore, DamageEvent>(DamageEvent::class.java) {
    override fun getQuery() = Query.and(HealthComponentType, Query.not(InvulnerableType))

    override fun handle(
        index: Int,
        chunk: ArchetypeChunk<EntityStore>,
        store: Store<EntityStore>,
        buffer: CommandBuffer<EntityStore>,
        event: DamageEvent
    ) {
        // Runs on world thread, per matching entity
        val health = chunk.getComponent(index, HealthComponentType)
        health.damage(event.amount)
    }
}
```

### Thread Safety

Events run on specific threads:

```kotlin
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    // This runs on the event bus thread, NOT the world thread

    val world = event.world ?: return@register

    // For world modifications, schedule on world thread
    world.execute {
        // Safe to modify world here
        world.entityStore.store.addEntity(holder, AddReason.SPAWN)
    }
}
```

### Event Chains

Trigger follow-up events after processing:

```kotlin
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    val playerRef = event.playerRef ?: return@register

    // Schedule a welcome message after player fully loads
    HytaleServer.SCHEDULED_EXECUTOR.schedule({
        playerRef.holder?.getComponent(Player.getComponentType())?.let { player ->
            player.sendMessage(Message.raw("Welcome to the server!"))

            // Could trigger custom event here
            eventRegistry.post(PlayerWelcomedEvent(playerRef))
        }
    }, 2, TimeUnit.SECONDS)
}
```

### Temporary Event Handlers

Register handlers that auto-unregister:

```kotlin
class OneTimeHandler(private val targetUuid: UUID) {
    private lateinit var registration: EventRegistration

    fun register(eventRegistry: EventRegistry) {
        registration = eventRegistry.register(PlayerReadyEvent::class.java) { event ->
            if (event.playerRef?.uuid == targetUuid) {
                handleFirstReady(event)
                registration.unregister()  // Remove this listener
            }
        }
    }

    private fun handleFirstReady(event: PlayerReadyEvent) {
        // One-time processing
    }
}
```

### Error Handling

Prevent one handler from breaking others:

```kotlin
eventRegistry.register(PlayerConnectEvent::class.java) { event ->
    try {
        riskyOperation(event)
    } catch (e: Exception) {
        logger.error("Failed to process connect event", e)
        // Don't rethrow - allow other handlers to run
    }
}
```

## Next Steps

- [Event List](/event-list) - All available events
- [Creating Commands](/creating-commands) - Add commands
- [Working with Players](/working-with-players) - Player manipulation
- [Advanced ECS](/advanced-ecs) - ECS event systems in depth
